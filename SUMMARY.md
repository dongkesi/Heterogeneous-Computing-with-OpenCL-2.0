# Table of contents

* [Introduction](README.md)
* [序言](foreword-chinese.md)
* [第1章 简介异构计算](1.0-chinese/README.md)
  * [1.1 关于异构计算](1.0-chinese/1.1-chinese.md)
  * [1.2 本书目的](1.0-chinese/1.2-chinese.md)
  * [1.3 并行思想](1.0-chinese/1.3-chinese.md)
  * [1.4 并发和并行编程模型](1.0-chinese/1.4-chinese.md)
  * [1.5 线程和共享内存](1.0-chinese/1.5-chinese.md)
  * [1.6 消息通讯机制](1.0-chinese/1.6-chinese.md)
  * [1.7 并行性的粒度](1.0-chinese/1.7-chinese.md)
  * [1.8 使用OpenCL进行异构计算](1.0-chinese/1.8-chinese.md)
  * [1.9 本书结构](1.0-chinese/1.9-chinese.md)
* [第2章 设备架构](2.0-chinese/README.md)
  * [2.1 介绍](2.0-chinese/2.1-chinese.md)
  * [2.2 硬件的权衡](2.0-chinese/2.2-chinese.md)
  * [2.3 架构设计空间](2.0-chinese/2.3-chinese.md)
  * [2.4 本章总结](2.0-chinese/2.4-chinese.md)
* [第3章 介绍OpenCL](3.0-chinese/README.md)
  * [3.1 简介OpenCL](3.0-chinese/3.1-chinese.md)
  * [3.2 OpenCL平台模型](3.0-chinese/3.2-chinese.md)
  * [3.3 OpenCL执行模型](3.0-chinese/3.3-chinese.md)
  * [3.4 内核和OpenCL编程模型](3.0-chinese/3.4-chinese.md)
  * [3.5 OpenCL内存模型](3.0-chinese/3.5-chinese.md)
  * [3.6 OpenCL运行时\(例子\)](3.0-chinese/3.6-chinese.md)
  * [3.7 OpenCL C++ Wapper向量加法](3.0-chinese/3.7-chinese.md)
  * [3.8 CUDA编程者使用OpenCL的注意事项](3.0-chinese/3.8-chinese.md)
* [第4章 OpenCL案例](4.0-chinese/README.md)
  * [4.1 OpenCL实例](4.0-chinese/4.1-chinese.md)
  * [4.2 直方图](4.0-chinese/4.2-chinese.md)
  * [4.3 图像旋转](4.0-chinese/4.3-chinese.md)
  * [4.4 图像卷积](4.0-chinese/4.4-chinese.md)
  * [4.5 生产者-消费者](4.0-chinese/4.5-chinese.md)
  * [4.6 基本功能函数](4.0-chinese/4.6-chinese.md)
  * [4.7 本章总结](4.0-chinese/4.7-chinese.md)
* [第5章 OpenCL运行时和并发模型](5.0-chinese/README.md)
  * [5.1 命令和排队模型](5.0-chinese/5.1-chinese.md)
  * [5.2 多命令队列](5.0-chinese/5.2-chinese.md)
  * [5.3 内核执行域:工作项、工作组和NDRange](5.0-chinese/5.3-chinese.md)
  * [5.4 原生和内置内核](5.0-chinese/5.4-chinese.md)
  * [5.5 设备端排队](5.0-chinese/5.5-chinese.md)
  * [5.6 本章总结](5.0-chinese/5.6-chinese.md)
* [第6章 OpenCL主机端内存模型](6.0-chinese/README.md)
  * [6.1 内存对象](6.0-chinese/6.1-chinese.md)
  * [6.2 内存管理](6.0-chinese/6.2-chinese.md)
  * [6.3 共享虚拟内存](6.0-chinese/6.3-chinese.md)
  * [6.4 本章总结](6.0-chinese/6.4-chinese.md)
* [第7章 OpenCL设备端内存模型](7.0-chinese/README.md)
  * [7.1 同步和交互](7.0-chinese/7.1-chinese.md)
  * [7.2 全局内存](7.0-chinese/7.2-chinese.md)
  * [7.3 常量内存](7.0-chinese/7.3-chinese.md)
  * [7.4 局部内存](7.0-chinese/7.4-chinese.md)
  * [7.5 私有内存](7.0-chinese/7.5-chinese.md)
  * [7.6 统一地址空间](7.0-chinese/7.6-chinese.md)
  * [7.7 内存序](7.0-chinese/7.7-chinese.md)
  * [7.8 本章总结](7.0-chinese/7.8-chinese.md)
* [第8章 异构系统下解析OpenCL](8.0-chinese/README.md)
  * [8.1 AMD FX-8350 CPU](8.0-chinese/8.1-chinese.md)
  * [8.2 AMD RADEON R9 290X CPU](8.0-chinese/8.2-chinese.md)
  * [8.3 OpenCL内存性能的考量](8.0-chinese/8.3-chinese.md)
  * [8.4 本章总结](8.0-chinese/8.4-chinese.md)
* [第9章 案例分析：图像聚类](9.0-chinese/README.md)
  * [9.1 图像聚类简介](9.0-chinese/9.1-chinese.md)
  * [9.2 直方图的特性——CPU实现](9.0-chinese/9.2-chinese.md)
  * [9.3 OpenCL实现](9.0-chinese/9.3-chinese.md)
  * [9.4 性能分析](9.0-chinese/9.4-chinese.md)
  * [9.5 本章总结](9.0-chinese/9.5-chinese.md)
* [第10章 OpenCL的分析和调试](10.0-chinese/README.md)
  * [10.1 设置本章的原因](10.0-chinese/10.1-chinese.md)
  * [10.2 使用事件分析OpenCL代码](10.0-chinese/10.2-chinese.md)
  * [10.3 AMD CodeXL](10.0-chinese/10.3-chinese.md)
  * [10.4 如何使用AMD CodeXL](10.0-chinese/10.4-chinese.md)
  * [10.5 使用CodeXL分析内核](10.0-chinese/10.5-chinese.md)
  * [10.6 使用CodeXL调试OpenCL内核](10.0-chinese/10.6-chinese.md)
  * [10.7 使用printf调试](10.0-chinese/10.7-chinese.md)
  * [10.8 本章总结](10.0-chinese/10.8-chinese.md)
* [第11章 高级语言映射到OpenCL2.0 —— 从编译器作者的角度](11.0-chinese/README.md)
  * [11.1 简要介绍现状](11.0-chinese/11.1-chinese.md)
  * [11.2 简单介绍C++ AMP](11.0-chinese/11.2-chinese.md)
  * [11.3 编译器的目标 —— OpenCL 2.0](11.0-chinese/11.3-chinese.md)
  * [11.4 C++ AMP与OpenCL对比](11.0-chinese/11.4-chinese.md)
  * [11.5 C++ AMP的编译流](11.0-chinese/11.5-chinese.md)
  * [11.6 编译之后的C++ AMP代码](11.0-chinese/11.6-chinese.md)
  * [11.7 OpenCL 2.0提出共享虚拟内存的原因](11.0-chinese/11.7-chinese.md)
  * [11.8 编译器怎样支持C++ AMP的线程块划分](11.0-chinese/11.8-chinese.md)
  * [11.9 地址空间的推断](11.0-chinese/11.9-chinese.md)
  * [11.10 优化数据搬运](11.0-chinese/11.10-chinese.md)
  * [11.11 完整例子:二项式](11.0-chinese/11.11-chinese.md)
  * [11.12 初步结果](11.0-chinese/11.12-chinese.md)
  * [11.13 本章总结](11.0-chinese/11.13-chinese.md)
* [第12章 WebCL：使用OpenCL加速Web应用](12.0-chinese/README.md)
  * [12.1 介绍WebCL](12.0-chinese/12.1-chinese.md)
  * [12.2 如何使用WebCL编程](12.0-chinese/12.2-chinese.md)
  * [12.3 同步机制](12.0-chinese/12.3-chinese.md)
  * [12.4 WebCL的交互性](12.0-chinese/12.4-chinese.md)
  * [12.5 应用实例](12.0-chinese/12.5-chinese.md)
  * [12.6 增强安全性](12.0-chinese/12.6-chinese.md)
  * [12.7 服务器端使用WebCL](12.0-chinese/12.7-chinese.md)
  * [12.8 WebCL的状态和特性](12.0-chinese/12.8-chinese.md)
* [第13章 其他高级语言中OpenCL的使用](13.0-chinese/README.md)
  * [13.1 本章简介](13.0-chinese/13.1-chinese.md)
  * [13.2 越过C和C++](13.0-chinese/13.2-chinese.md)
  * [13.3 Haskell中使用OpenCL](13.0-chinese/13.3-chinese.md)
  * [13.4 本章总结](13.0-chinese/13.4-chinese.md)

